# Database Documentation

## Overview

The Trading Bot uses a SQLite database to store trade signals, executed trades, and performance metrics. This enables historical analysis, dashboard visualization, and performance tracking.

## Database Schema

### Signals Table

Stores trading signals generated by the signal generators:

- `id`: Unique identifier (auto-incremented)
- `timestamp`: When the signal was generated
- `symbol`: Trading symbol (e.g., EURUSD)
- `timeframe`: Timeframe of the analysis (e.g., M15, H1, H4)
- `strategy`: Strategy that generated the signal
- `direction`: Buy or Sell
- `entry_price`: Recommended entry price
- `stop_loss`: Stop loss price
- `take_profit`: Take profit price
- `current_price`: Price at time of signal generation
- `confidence`: Confidence score (0-1)
- `description`: Human-readable description of the signal
- `position_size`: Recommended position size
- `risk_amount`: Risk amount in account currency
- `market_condition`: Market condition assessment
- `volatility_state`: Market volatility assessment
- `session`: Trading session (e.g., London, New York)
- `htf_bias`: Higher timeframe bias
- `raw_data`: Full JSON signal data for future reference
- `status`: Signal status (active, executed, rejected, expired)
- `executed`: Whether the signal was executed
- `execution_time`: When the signal was executed

### Trades Table

Stores executed trades:

- `id`: Unique identifier (auto-incremented)
- `signal_id`: Reference to the signal that generated this trade
- `ticket`: Broker's ticket/order number
- `symbol`: Trading symbol
- `direction`: Buy or Sell
- `entry_price`: Actual entry price
- `current_price`: Current or closing price
- `stop_loss`: Stop loss price
- `take_profit`: Take profit price
- `position_size`: Actual position size
- `open_time`: When the trade was opened
- `close_time`: When the trade was closed (if applicable)
- `profit_loss`: Realized profit/loss
- `profit_loss_pips`: Profit/loss in pips
- `status`: Trade status (open, closed)

### Performance Metrics Table

Stores calculated performance metrics for different timeframes:

- `id`: Unique identifier (auto-incremented)
- `date`: Date of the metrics calculation
- `total_trades`: Total number of trades in the period
- `winning_trades`: Number of winning trades
- `losing_trades`: Number of losing trades
- `win_rate`: Win rate percentage
- `profit_loss`: Total profit/loss
- `profit_loss_percentage`: Profit/loss as percentage of balance
- `average_win`: Average profit of winning trades
- `average_loss`: Average loss of losing trades
- `largest_win`: Largest winning trade
- `largest_loss`: Largest losing trade
- `drawdown`: Maximum drawdown percentage
- `sharpe_ratio`: Sharpe ratio
- `timeframe`: Timeframe of the metrics (1D, 1W, 1M, etc.)

## Usage

The database is implemented as a singleton instance for easy access throughout the application:

```python
from src.database import db

# Insert a signal
signal_id = db.insert_signal(signal_data)

# Insert a trade
trade_id = db.insert_trade(trade_data, signal_id)

# Get active signals
active_signals = db.get_active_signals()

# Get active trades
active_trades = db.get_active_trades()

# Calculate and store performance metrics
metrics = db.calculate_performance_metrics('1W')
db.update_or_insert_performance_metrics(metrics)
```

## Database File

The database is stored in a SQLite file at the root of the project:

```
/trading_data.db
```

This file contains all the tables and data. It can be backed up by simply copying the file or using SQLite's backup functionality.

## Integration Points

The database is integrated with the following components:

1. **Signal Generators**: Store generated signals
2. **Trading Bot**: Record executed trades and trade outcomes
3. **Dashboard API**: Retrieve data for visualization
4. **Performance Tracking**: Calculate and store metrics

## Performance Considerations

- The SQLite database is suitable for the trading bot's needs but may need to be replaced with a more robust solution (like PostgreSQL) for very high-frequency trading.
- Regular database maintenance (vacuum, indexes) is recommended for optimal performance.
- Consider implementing a backup strategy for the database file. 